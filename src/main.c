#if 0
	Toolkit By ViewTech Official
	join Group: https://t.me/+NlHuKTzhZbRkMTJl
#endif

static  char data [] = 
#define      pswd_z	256
#define      pswd	((&data[0]))
	"\006\125\367\137\344\247\046\054\350\202\055\221\312\134\123\355"
	"\000\344\272\115\054\055\301\111\001\364\257\156\051\134\003\060"
	"\262\373\220\226\242\267\302\212\071\360\034\003\114\160\360\114"
	"\124\253\232\201\330\133\313\331\117\172\110\171\327\113\252\211"
	"\107\072\037\352\361\342\164\052\323\220\056\037\000\037\153\125"
	"\312\006\327\243\141\242\174\261\034\304\053\364\020\325\175\130"
	"\017\235\102\000\200\266\053\123\107\131\163\110\171\337\236\103"
	"\345\165\346\106\027\143\370\064\050\043\050\071\370\246\221\010"
	"\104\324\010\304\213\063\030\322\215\213\033\006\152\271\112\117"
	"\056\061\226\106\225\217\172\275\262\243\366\253\111\210\263\215"
	"\134\274\122\350\360\153\272\176\366\326\204\141\217\317\261\276"
	"\000\110\004\225\327\176\123\212\041\112\066\153\323\352\371\060"
	"\246\113\030\227\266\323\025\255\251\232\017\071\151\300\367\152"
	"\011\374\000\341\173\123\153\234\236\242\010\161\214\001\241\062"
	"\114\271\311\003\215\337\261\066\171\300\160\343\201\147\115\212"
	"\144\116\153\337\242\327\174\100\171\204\262\005\205\124\070\322"
	"\232\341\207\321\133\110\101\076\311\251\214\124\015\332\300\354"
	"\175\230\150\276\021\355\160\027\162\304\120\105\322\122\033\155"
	"\064\243\076\217\353\200\316\265\052\133\011\067\065\312\044\263"
	"\142\215\161\164\172\341"
#define      chk1_z	22
#define      chk1	((&data[315]))
	"\334\062\170\057\116\371\330\122\042\256\006\130\222\256\211\010"
	"\170\320\375\236\345\213\360\205\372\223\203\345\143\361"
#define      date_z	1
#define      date	((&data[340]))
	"\203"
#define      msg2_z	19
#define      msg2	((&data[344]))
	"\317\035\234\261\330\053\020\275\270\103\302\052\127\327\221\263"
	"\261\071\031\021\010\221\006\123"
#define      lsto_z	1
#define      lsto	((&data[365]))
	"\312"
#define      opts_z	1
#define      opts	((&data[366]))
	"\251"
#define      shll_z	41
#define      shll	((&data[369]))
	"\311\037\120\230\307\051\060\032\366\340\344\362\227\147\131\260"
	"\206\074\276\235\261\032\231\163\010\253\261\071\240\212\322\315"
	"\364\032\242\066\320\062\124\207\362\112\056\377\245\121"
#define      tst1_z	22
#define      tst1	((&data[417]))
	"\134\070\221\201\263\067\221\315\061\250\240\105\214\305\030\312"
	"\063\370\353\350\053\136\343\367\165\236\054\157\046"
#define      tst2_z	19
#define      tst2	((&data[442]))
	"\061\370\273\211\220\070\374\341\245\356\140\307\133\157\371\133"
	"\250\200\305\013\236\374\136"
#define      msg1_z	60
#define      msg1	((&data[467]))
	"\316\340\240\243\123\355\320\047\234\061\014\253\161\046\201\307"
	"\276\164\254\155\232\142\011\173\305\005\141\027\015\000\366\153"
	"\173\300\240\257\120\057\274\221\100\214\262\245\075\143\324\245"
	"\124\325\000\121\125\066\253\071\311\310\166\210\242\243\334\014"
	"\022\065\326\061"
#define      inlo_z	3
#define      inlo	((&data[533]))
	"\001\141\130"
#define      rlax_z	1
#define      rlax	((&data[536]))
	"\070"
#define      xecc_z	15
#define      xecc	((&data[539]))
	"\212\266\336\322\232\302\132\343\137\035\144\151\255\122\217\066"
	"\225\044\260"
#define      text_z	1543
#define      text	((&data[613]))
	"\260\304\243\016\312\312\163\231\253\117\245\275\205\174\357\271"
	"\370\163\145\111\227\155\323\114\370\212\161\250\056\227\117\336"
	"\134\362\355\046\275\140\277\150\260\145\045\065\341\025\356\331"
	"\210\123\043\040\301\367\154\271\201\067\213\222\062\212\145\233"
	"\204\004\006\364\244\033\241\172\207\153\061\340\130\322\176\021"
	"\221\005\220\131\157\126\154\161\115\175\367\106\222\005\355\213"
	"\150\024\122\330\277\137\104\374\235\352\065\230\004\331\301\155"
	"\152\342\343\046\224\140\264\157\337\054\022\110\273\315\270\147"
	"\376\244\310\273\270\052\245\026\355\214\246\171\130\126\325\032"
	"\212\370\341\367\063\330\063\023\121\125\276\261\106\071\157\275"
	"\046\020\255\043\105\305\332\051\362\157\135\107\360\215\152\201"
	"\200\274\371\172\006\001\235\041\304\121\131\025\026\213\046\313"
	"\112\105\042\107\105\034\102\161\367\201\114\062\134\332\022\246"
	"\310\054\261\060\112\160\376\335\355\001\360\173\270\255\265\114"
	"\170\153\040\176\216\120\173\265\137\055\356\051\260\245\071\014"
	"\064\262\000\015\235\163\137\002\052\366\362\317\005\340\240\123"
	"\041\313\327\113\337\337\234\161\161\033\071\065\011\331\313\302"
	"\356\356\046\370\303\176\204\210\157\335\223\065\310\135\347\044"
	"\167\116\375\013\304\240\002\014\305\244\031\352\176\213\143\167"
	"\064\271\350\240\021\013\050\104\263\371\260\310\124\255\255\057"
	"\043\327\036\151\124\043\322\026\152\054\036\117\022\007\243\275"
	"\005\271\222\265\160\155\352\150\102\340\022\021\214\021\147\103"
	"\344\363\104\336\055\175\066\250\233\160\367\234\275\272\244\113"
	"\076\013\340\233\104\037\221\217\045\371\312\060\136\246\213\213"
	"\017\267\257\073\072\033\271\226\200\336\025\125\136\173\043\311"
	"\162\144\054\107\256\130\006\115\371\265\304\162\340\047\102\232"
	"\177\202\213\130\002\241\114\123\055\246\073\030\145\071\143\140"
	"\165\040\152\344\373\243\370\133\274\307\161\147\041\171\274\352"
	"\173\170\036\111\041\161\316\265\303\217\005\314\147\224\162\047"
	"\255\254\165\321\132\305\161\032\337\165\250\351\035\220\174\020"
	"\100\272\075\317\030\215\070\320\366\322\365\111\137\163\022\231"
	"\240\245\246\370\227\205\306\221\366\363\323\017\143\061\256\012"
	"\322\330\322\326\322\036\214\226\232\175\227\235\245\067\307\172"
	"\237\013\346\001\126\310\175\072\344\044\104\011\376\124\200\000"
	"\234\141\203\156\020\345\151\027\125\331\052\207\333\060\012\040"
	"\126\277\370\306\313\271\137\314\215\002\351\371\152\125\131\271"
	"\320\111\206\211\340\000\246\146\370\070\065\323\325\045\254\051"
	"\173\312\366\076\010\314\061\243\374\311\371\373\202\131\251\244"
	"\371\326\257\155\134\023\305\005\141\274\226\154\335\142\036\211"
	"\000\252\307\166\244\310\271\302\107\107\334\176\301\150\114\217"
	"\272\273\051\075\033\367\201\053\131\031\306\143\100\330\331\164"
	"\260\115\175\105\076\313\000\105\025\335\336\324\017\043\346\151"
	"\162\302\372\354\050\313\346\106\300\211\205\063\045\002\362\075"
	"\110\247\151\371\104\134\273\270\065\372\302\050\007\211\354\232"
	"\161\314\260\206\051\025\113\052\253\125\105\141\071\254\344\203"
	"\375\033\004\210\305\100\140\146\324\072\046\153\372\304\121\016"
	"\326\037\120\125\251\301\045\346\110\211\166\075\320\002\334\375"
	"\361\227\225\323\233\127\056\360\333\163\265\272\002\047\276\161"
	"\032\365\121\202\201\004\201\143\204\221\077\222\257\330\275\370"
	"\015\260\220\013\146\175\023\051\115\057\046\334\217\124\273\141"
	"\044\112\202\230\254\356\366\073\230\204\241\363\150\324\050\033"
	"\112\020\355\156\130\175\005\301\330\300\212\002\327\373\030\264"
	"\315\075\140\325\361\155\213\161\141\013\246\176\203\057\223\155"
	"\313\110\132\363\254\166\144\323\056\214\204\035\067\073\251\126"
	"\103\244\362\313\014\024\056\212\352\151\061\011\137\311\334\156"
	"\354\024\262\236\277\165\363\313\120\360\052\236\221\104\343\030"
	"\036\120\173\255\012\113\146\202\316\026\065\361\347\277\362\237"
	"\057\372\050\305\206\260\277\074\150\357\217\046\023\037\351\220"
	"\315\135\005\365\051\164\304\372\046\323\114\115\246\067\203\162"
	"\370\371\375\007\224\137\041\250\050\043\111\057\073\165\172\222"
	"\205\011\340\377\010\257\071\123\026\326\245\304\004\211\333\156"
	"\314\342\343\025\220\022\336\062\030\362\301\211\105\134\331\261"
	"\332\204\100\263\227\362\373\231\035\046\005\305\026\160\160\366"
	"\274\134\001\150\166\245\351\357\036\256\323\070\304\003\164\040"
	"\262\365\206\112\216\154\227\064\032\017\117\120\342\020\010\177"
	"\347\142\157\335\054\177\145\357\052\361\352\110\350\152\051\265"
	"\312\304\224\005\270\253\036\076\163\060\153\165\271\065\000\246"
	"\111\144\140\077\174\071\250\075\131\362\221\275\337\252\307\364"
	"\164\136\301\205\134\344\017\037\312\366\251\305\203\301\304\347"
	"\374\320\303\150\076\077\342\354\062\231\150\141\134\301\127\355"
	"\316\065\353\376\331\307\167\272\037\357\306\252\256\326\212\007"
	"\374\123\017\374\272\247\337\204\300\301\146\304\161\067\212\345"
	"\031\140\177\147\174\017\200\362\323\361\173\315\150\241\000\375"
	"\360\263\203\375\100\217\155\132\150\334\315\173\007\147\354\327"
	"\251\353\006\055\040\337\147\116\324\253\142\154\207\364\272\344"
	"\365\015\304\101\250\113\326\344\000\367\034\252\051\325\156\060"
	"\042\015\232\272\065\041\377\226\377\224\177\166\265\273\264\331"
	"\103\152\110\352\126\155\326\032\242\013\351\071\122\035\361\234"
	"\062\171\311\321\071\214\273\314\155\064\177\305\051\222\216\264"
	"\357\331\211\143\257\250\042\342\220\370\036\075\200\042\033\057"
	"\032\173\323\311\110\240\112\164\333\106\257\310\256\144\362\062"
	"\037\230\207\056\171\130\135\176\251\206\174\111\301\372\215\350"
	"\335\042\211\235\245\214\135\316\046\275\050\276\102\167\371\167"
	"\034\327\323\336\035\157\225\072\076\253\173\121\124\233\077\003"
	"\371\207\052\154\067\076\217\160\263\275\352\172\262\035\367\270"
	"\144\143\207\201\173\166\122\102\241\225\216\237\330\107\233\173"
	"\010\166\336\051\063\152\200\001\351\215\345\154\003\120\045\254"
	"\016\273\071\061\362\132\043\203\053\053\253\232\034\120\105\200"
	"\060\055\057\271\113\357\022\135\061\070\332\140\214\037\260\315"
	"\103\267\116\270\371\161\157\067\310\223\236\205\006\043\303\365"
	"\014\053\032\233\000\110\350\225\366\354\164\224\060\124\322\340"
	"\152\202\171\334\071\231\225\325\237\044\146\361\325\127\141\176"
	"\124\052\226\162\032\155\342\132\361\157\362\316\107\010\116\236"
	"\146\105\330\172\331\213\110\265\131\334\376\200\244\370\044\375"
	"\360\006\207\263\336\343\020\311\124\210\206\133\324\201\120\310"
	"\315\362\050\206\355\304\252\354\354\003\043\070\214\041\352\272"
	"\343\121\070\032\370\343\353\310\005\322\215\365\234\105\026\033"
	"\326\340\047\172\136\050\072\227\261\372\011\242\016\253\272\070"
	"\215\204\034\275\313\046\006\163\243\323\360\061\015\031\360\360"
	"\075\213\137\347\352\246\271\102\250\206\030\047\313\142\251\033"
	"\336\142\260\166\261\216\322\243\173\371\140\334\271\311\214\036"
	"\356\301\377\004\257\331\215\003\375\255\305\365\032\177\166\370"
	"\341\046\156\223\265\101\066\060\072\227\014\363\140\231\022\117"
	"\132\022\124\012\354\341\016\351\217\323\336\251\122\125\242\064"
	"\173\021\307\060\122\376\141\215\226\156\201\367\007\223\107\142"
	"\245\233\154\222\175\173\173\015\116\132\266\241\257\131\326\053"
	"\152\236\134\275\234\275\113\063\054\314\053\064\140\162\226\005"
	"\016\003\230\213\176\023\230\315\156\117\157\035\251\105\111\024"
	"\343\245\322\200\143\035\263\217\351\336\303\111\121\132\117\137"
	"\135\347\353\333\373\204\250\151\323\027\207\175\135\320\221\100"
	"\166\143\301\331\200\164\151\152\123\054\263\245\206\003\004\344"
	"\353\360\277\346\164\150\120\110\200\327\305\335\250\127\036\037"
	"\272\337\370\073\124\141\245\250\216\131\115\025\134\122\372\107"
	"\102\272\056\267\042\176\377\243\126\305\201\376\034\240\035\326"
	"\200\026\022\324\170\267\175\007\021\312\035\155\035\027\265\140"
	"\321\344\027\364\142\027\230\270\334\031"
#define      chk2_z	19
#define      chk2	((&data[2410]))
	"\325\317\072\354\203\206\231\114\134\170\044\345\321\344\352\273"
	"\302\252\041\262\331\016\316\341\016\145";
#define      hide_z	4096
#define SETUID 0	
#define DEBUGEXEC	0	
#define TRACEABLE	0	
#define HARDENING	0	
#define BUSYBOXON	0	

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Null",
" * Null",
" * Null",
" * Null",
" */",
"",
"#define _GNU_SOURCE ",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif



#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>



static unsigned char stte[256], indx, jndx, kndx;


void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}


void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}


void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}


#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    Allow(exit_group),  
    Allow(brk),         
    Allow(mmap),        
    Allow(munmap),      

    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
}

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/data/data/com.termux/files/usr/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "clang";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/data/data/com.termux/files/usr/tmp/shc_x.so", "/data/data/com.termux/files/usr/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/data/data/com.termux/files/usr/tmp/shc_x.c"); return -1;}
	remove("/data/data/com.termux/files/usr/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/data/data/com.termux/files/usr/tmp/shc_x.so",1);

    if(pid==0) {

        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        system(tmp2);

        memcpy(tmp2, str, lentmp);

        remove("/data/data/com.termux/files/usr/tmp/shc_x.so");

        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    seccomp_hardening();

    exit(0);
}
#endif


int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) 
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();

#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif 

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);

       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;

		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		
#endif
	if (ret && *opts)
		varg[j++] = opts;	
	if (*inlo)
		varg[j++] = inlo;	
	varg[j++] = scrpt;		
	if (*lsto)
		varg[j++] = lsto;	
	i = (ret > 1) ? ret : 0;	
	while (i < argc)
		varg[j++] = argv[i++];	
	varg[j] = 0;			
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
